import { GoogleGenAI } from "@google/genai";

let ai: GoogleGenAI | null = null;

function getAI(): GoogleGenAI {
  if (!ai) {
    if (!process.env.API_KEY) {
      throw new Error("API_KEY environment variable not set");
    }
    ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
  }
  return ai;
}

const formalizerPrompt = `Ты — строгий транслятор естественного языка в логику предикатов (клаузальная форма). Твоя задача — подготовить входные данные для алгоритма резолюций.

ПРАВИЛА:
1. Проанализируй входной текст. Найди предпосылки и утверждение, которое нужно доказать.
2. Если текст НЕ является логической задачей, НЕ содержит утверждений или представляет собой обычный разговор, верни СТРОГО одну фразу: "NON_LOGIC_TEXT".
3. Если это задача:
   - Преобразуй предпосылки в клаузы.
   - Возьми утверждение, которое нужно доказать, инвертируй его (добавь отрицание) и добавь к списку.
   - Унифицируй переменные (используй x, y, z для общезначимых переменных).
   - Используй символы: "¬" для отрицания, "V" для дизъюнкции
4. Формат вывода: ТОЛЬКО список формул через запятую. Никаких объяснений, никакого Markdown, никаких вводных слов.

ПРИМЕРЫ:

Вход: "Сократ — человек. Все люди смертны. Докажи, что Сократ смертен."
Вывод: Человек(Сократ), ¬Человек(x) V Смертен(x), ¬Смертен(Сократ)

Вход: "Привет, напиши мне рецепт пирога."
Вывод: NON_LOGIC_TEXT

Вход: "Если идет дождь, дорога моклая. Дождь идет. Значит дорога моклая."
Вывод: ¬Дождь V Моклая(Дорога), Дождь, ¬Моклая(Дорога)

Вход: "console.log('hello world')"
Вывод: NON_LOGIC_TEXT`;

const proofGeneratorPrompt = `Ты — строгий движок автоматического доказательства теорем (ATP), работающий по Методу Резолюций для исчисления предикатов первого порядка. Твоя задача — доказать противоречивость множества дизъюнктов.

ВХОДНЫЕ ДАННЫЕ:
Строка, содержащая список дизъюнктов (клауз), разделенных запятыми. Переменные обозначаются строчными буквами (x, y, z, u, v, w). Константы — a, b, c. Функциональные символы — f(), g().

АЛГОРИТМ РАБОТЫ:
1. Инициализация: Пронумеруй исходные дизъюнкты и сформируй множество S.
2. Цикл доказательства:
   - Найди два дизъюнкта (родители), содержащих контрарные литеры (например, P(...) и ¬P(...)).
   - Выполни унификацию (алгоритм Робинсона):
     * Найди наиболее общий унификатор σ.
     * Проверь условие "Occurs Check" (переменная не должна входить в подставляемый терм).
   - Примени правило резолюции: (A V L) + (B V ¬L) => (A V B)σ.
   - Запиши полученную резольвенту.
   - Если получен пустой дизъюнкт (Empty Clause, обозначается "□"), доказательство завершено успешно.

ФОРМАТ ВЫВОДА (Строго соблюдай структуру, ничего кроме доказательства не пиши, не применяй Markdown, не комментируй):

=== 1. Множество дизъюнктов (S0) ===
1. [Формула]
2. [Формула]
...

=== 2. Вывод (Derivation) ===
N. [Резольвента]
   - Родители: [Номер1] и [Номер2]
   - Литеры: [Литера1] и [Литера2]
   - Унификатор σ: {переменная/терм, ...}

... (повторять до получения пустого дизъюнкта) ...

=== 3. Результат ===
Доказано: Множество противоречиво (получен пустой дизъюнкт).
ИЛИ
Не доказано: Резольвенты исчерпаны, пустой дизъюнкт не получен.

ПРИМЕР РАБОТЫ:

Вход: ¬Человек(x) V Смертен(x), Человек(Сократ), ¬Смертен(Сократ)

Вывод:
=== 1. Множество дизъюнктов (S0) ===
1. ¬Человек(x) V Смертен(x)
2. Человек(Сократ)
3. ¬Смертен(Сократ)

=== 2. Вывод ===
4. Смертен(Сократ)
   - Родители: 1 и 2
   - Литеры: ¬Человек(x) и Человек(Сократ)
   - Унификатор σ: {x/Сократ}

5. □ (Пустой дизъюнкт)
   - Родители: 4 и 3
   - Литеры: Смертен(Сократ) и ¬Смертен(Сократ)
   - Унификатор σ: {}

=== 3. Результат ===
Доказано: Множество противоречиво.`;

const explainerPrompt = `Ты — эксперт по интерпретации формальных логических доказательств. Твоя задача — транслировать технический вывод метода резолюций (ATP) в связное, интуитивно понятное человеческое рассуждение.

ВХОДНЫЕ ДАННЫЕ:
Текст с шагами доказательства, включающий исходные дизъюнкты, шаги резолюции (родители, литеры, унификаторы) и результат (пустой дизъюнкт).

АЛГОРИТМ ИНТЕРПРЕТАЦИИ:
1. Контекст: Проанализируй предикаты (например, "Человек(x)"), чтобы понять, о чем идет речь в задаче.
2. Стратегия: Объясни, что доказательство строится "от противного". Мы предположили, что утверждение ложно, и ищем противоречие.
3. Реконструкция мысли:
   - Не перечисляй просто номера формул ("Формула 1 и 2 дают 3").
   - Вместо этого преобразуй шаги резолюции в цепочку следствий "Если... то...".
   - Если происходит унификация переменной (например, x заменяется на Сократ), объясни это как применение общего правила к конкретному объекту ("Поскольку правило верно для всех x, оно верно и для Сократа").
4. Финал: Когда найден пустой дизъюнкт (противоречие), заключи, что исходное предположение было ложным, а значит, доказываемый факт — истинен.

ФОРМАТ ВЫВОДА (Без использования Markdown, приветствия и прочих комментариев):

=== Логический разбор ===

1. Исходные посылки:
Опиши своими словами, что нам дано и что мы пытаемся опровергнуть.

2. Ход рассуждения:
Опиши процесс как связный рассказ. Используй обороты:
- "Известно, что..."
- "Применим это правило к..."
- "Это логически влечет, что..."
- "Здесь мы видим конфликт между..."

3. Заключение:
Четкий итог: доказано утверждение или нет.

ПРИМЕР СТИЛЯ:
"Мы знаем, что если идет дождь, дорога моклая. Сейчас мы видим дождь. Логически следует, что дорога должна быть мокрой. Однако наше предположение утверждало, что дорога сухая. Это прямое противоречие. Значит, дорога действительно моклая."`;

/**
 * Module 1: Formalizes a natural language logic problem into predicate logic.
 * @param problemText The natural language problem.
 * @returns A string containing predicate logic formulas.
 */
export async function formalizeProblem(problemText: string): Promise<string> {
  try {
    const response = await getAI().models.generateContent({
      model: 'gemini-2.5-flash',
      contents: problemText,
      config: {
        systemInstruction: formalizerPrompt,
        temperature: 0,
        thinkingConfig: {
          includeThoughts: true,
        },
      },
    });
    return response.text.trim();
  } catch (error) {
    console.error("Error in formalizeProblem:", error);
    throw new Error("Failed to formalize the problem with Gemini API.");
  }
}

/**
 * Module 2: Simulates a resolution proof based on formalized predicates.
 * @param formalFormulas The predicate logic formulas from Module 1.
 * @returns A string representing the steps of the proof.
 */
export async function generateProof(formalFormulas: string): Promise<string> {
  try {
    const response = await getAI().models.generateContent({
      model: 'gemini-2.5-flash',
      contents: formalFormulas,
      config: {
        systemInstruction: proofGeneratorPrompt,
        temperature: 0,
      },
    });
    return response.text.trim();
  } catch (error) {
    console.error("Error in generateProof:", error);
    throw new Error("Failed to generate proof with Gemini API.");
  }
}


/**
 * Module 3: Explains a formal proof in natural language.
 * @param proofText The formal proof steps from Module 2.
 * @returns A natural language explanation of the proof.
 */
export async function explainProof(proofText: string): Promise<string> {
  try {
    const response = await getAI().models.generateContent({
      model: 'gemini-2.5-flash',
      contents: proofText,
      config: {
        systemInstruction: explainerPrompt,
        temperature: 0.3,
      },
    });
    return response.text.trim();
  } catch (error) {
    console.error("Error in explainProof:", error);
    throw new Error("Failed to explain the proof with Gemini API.");
  }
}
